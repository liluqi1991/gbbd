<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>gbbd</title>
    <style>
        /* 锁定微信字体缩放 */
        html {
            font-size: 16px !important;
            -webkit-text-size-adjust: 100% !important;
            text-size-adjust: 100% !important;
            -moz-text-size-adjust: 100% !important;
            -ms-text-size-adjust: 100% !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "PingFang SC", "STKaiti", "KaiTi", serif;
            font-size: inherit !important;
        }

        body {
            background: linear-gradient(120deg, #fff1f9, #ffd1dc, #ffc1e9);
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            height: -webkit-fill-available;
            width: -webkit-fill-available;
            -webkit-text-size-adjust: none !important;
            text-size-adjust: none !important;
        }

        /* 星星效果 */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            display: none;
        }

        .star {
            position: absolute;
            background: #fff;
            border-radius: 2px;
            -webkit-clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            animation: twinkle 1.8s infinite ease-in-out;
            opacity: 0.4;
            -webkit-animation: twinkle 1.8s infinite ease-in-out;
        }

        @-webkit-keyframes twinkle {
            0% { opacity: 0.4; -webkit-transform: scale(0.9); transform: scale(0.9); }
            50% { opacity: 1.2; -webkit-transform: scale(1.4); transform: scale(1.4); }
            100% { opacity: 0.4; -webkit-transform: scale(0.9); transform: scale(0.9); }
        }

        @keyframes twinkle {
            0% { opacity: 0.4; transform: scale(0.9); }
            50% { opacity: 1.2; transform: scale(1.4); }
            100% { opacity: 0.4; transform: scale(0.9); }
        }

        /* 诗句容器 - 上下无间距，正常显示 */
        .poem-container {
            position: relative;
            z-index: 2;
            max-width: 320px;
            margin: 0 auto;
            padding: 0 15px; /* 仅左右内边距 */
            background: transparent;
            height: 100vh;
            max-height: -webkit-fill-available;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
            display: none;
            -webkit-overflow-scrolling: touch;
        }

        .poem-container.show {
            display: block;
        }

        .poem-container::-webkit-scrollbar {
            display: none;
        }

        /* 诗句文字 - 关键修复：
           1. 初始transform移到屏幕外
           2. 新增top-margin，确保手动滑回时第一行与顶部有正常行距（一个行距）
        */
        .poem-content {
            color: #4a3246;
            font-size: 16px !important;
            line-height: 2.4;
            text-align: left;
            white-space: pre-line;
            font-weight: 400;
            position: relative;
            z-index: 3;
            /* 正常顶部边距：一个行距（line-height:2.4 → 约16*2.4=38.4px，取38px） */
            margin-top: 38px;
            /* 初始位置：屏幕底部外（默认不可见） */
            transform: translateY(calc(100vh + 100px));
            -webkit-transform: translateY(calc(100vh + 100px));
            /* 保证transform变化平滑 */
            transition: transform 0.1s ease;
            -webkit-transition: transform 0.1s ease;
        }

        /* 媒体查询适配边距 */
        @media (min-width: 390px) {
            .poem-container {
                max-width: 340px;
            }
            .poem-content {
                font-size: 18px !important;
                line-height: 2.5;
                /* 适配后行距：18*2.5=45px */
                margin-top: 45px;
            }
        }

        /* 密码遮罩 */
        .password-mask {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            width: -webkit-fill-available;
            height: 100vh;
            height: -webkit-fill-available;
            background: #ffd1dc;
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            opacity: 1;
            pointer-events: auto;
            /* 遮罩隐藏动画同步 */
            transition: opacity 0.5s ease;
            -webkit-transition: opacity 0.5s ease;
        }

        .mask-hint {
            color: #d63384;
            font-size: 22px !important;
            font-weight: 600;
            margin-bottom: 20px;
            letter-spacing: 3px;
            text-align: center;
            text-transform: lowercase;
            display: none;
        }

        .password-input {
            width: 100%;
            max-width: 280px;
            padding: 15px 20px;
            border: 2px solid #d63384;
            border-radius: 30px;
            background: #fff;
            font-size: 17px !important;
            color: #d63384;
            outline: none;
            text-align: center;
            letter-spacing: 2px;
            display: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .password-input:focus {
            border-color: #d63384;
            box-shadow: 0 0 15px rgba(214, 51, 132, 0.3);
            -webkit-box-shadow: 0 0 15px rgba(214, 51, 132, 0.3);
        }

        /* 加载提示 */
        .loading-indicator {
            color: #d63384;
            font-size: 18px !important;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>

    <div class="password-mask" id="passwordMask">
        <div class="loading-indicator" id="loadingIndicator">加载中...</div>
        <div class="mask-hint" id="maskHint">请输入密码</div>
        <!-- 自动获焦 -->
        <input type="password" class="password-input" id="passwordInput" placeholder="输入密码自动解锁" autofocus>
    </div>

    <div class="poem-container" id="poemContainer">
        <div class="poem-content" id="poemContent">
初见那一刻，你眼底的光如流星撞进我心间
我们走过天街，灯影追着脚步轻旋
沿着夜晚的河岸漫步，踏乱月影如碎银片片
秋千轻摇，摇出初见的丝丝微甜
走上西兴大桥，看两岸灯火点点，晚风卷起衣角翩翩
倚在江边楼顶，夕阳和晚霞铺满眼前
漫步清河古街，指尖掠过青瓦墙垣
穿行西湖苏堤畔，裙角被露水沾满
长椅上看流云舒卷，花丛边看蝶影翩跹
每一处驻足，都印着我们的身影点点
时光忽然停滞，像风筝越升越高，线轴无声飞转
忽然一声轻响，只剩风萦绕耳边
————
新年钟声响起，我们去人海中跨年，在送别时相见
与你重逢的瞬间，对视的目光没有陌生，只有炽热蔓延
纵然知道你将走向天边，也愿握住这份温暖
深夜车轮轻响深巷，街灯泛着昏黄光线
心里藏着欢喜，也裹着细碎的伤感
像是纪念过往走过的晨昏，又像给这段忽明忽暗的路写下句点
五彩气球从人群中挣脱，飞向暗蓝的天，眼前一切如梦如幻
不知道是重逢的斑斓，
还是怕你像气球飞远，只留我空握余温在掌间
————
转眼来到春天，草莓成熟时又相见
像梦一场，情节忽然反转
我们一起骑车，掠过林荫和江岸
一起散步在公园，呼吸荷花的丝丝香甜
一起看凌晨的日出，夜晚黑色变成凌晨的漫天火焰
一起让风掀起衣角，穿梭在城市的脉络间
一起牵着手爬山，迈过一级级石坎
风里夹着悄悄话，轻轻吹进彼此耳畔
我们并肩昂桑湖纤道，踏着苏州古镇青石板，
看小河流淌，把双脚浸入水波之间
倚着黄浦江游船，看两岸高楼深入云端
骑上千岛湖长桥，看水雾漫过远山
我们一起探店，尝遍街角的烟火小餐
一起在菜市场挑挑拣拣，回家做出鲜香酸甜
一起计算柴米油盐，精打细算筹划明天
幸福就印在生活里的点点滴滴，藏在时光里的平平淡淡
————
转眼走过一春秋，时光悄然流转
花开花落，寒来暑往，季节又回到初见
风里的味道依然是当初那般清甜
又想回到天街河边，重温相遇的心动瞬间，拾起过往碎碎片段
只是这一次，想停在婚姻登记处前
和你一起推开那扇门，携手相依，直到永远
        </div>
    </div>

    <audio id="backgroundMusic" loop>
        <source src="background.mp3" type="audio/mpeg">
        您的浏览器不支持音频播放
    </audio>

    <script>
        // 核心元素
        const audio = document.getElementById('backgroundMusic');
        const passwordMask = document.getElementById('passwordMask');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const maskHint = document.getElementById('maskHint');
        const passwordInput = document.getElementById('passwordInput');
        const stars = document.getElementById('stars');
        const poemContainer = document.getElementById('poemContainer');
        const poemContent = document.getElementById('poemContent');
        const correctPassword = 'abb';

        // 标记是否已经显示密码界面（防止重复触发）
        let isPasswordUIShowed = false;
        // 动画状态管理
        let isAnimating = false; // 是否正在执行上滑动画
        let animationFrameId = null; // 动画帧ID，用于取消动画

        // 页面加载完成初始化
        document.addEventListener('DOMContentLoaded', () => {
            initStars();
            loadAudioGracefully(); // 确保音频加载完成后再显示密码界面

            // 字体缩放兜底
            window.addEventListener('resize', () => {
                document.documentElement.style.fontSize = '16px !important';
                document.body.style.webkitTextSizeAdjust = 'none !important';
            }, { passive: true });
        });

        // 初始化星星
        function initStars() {
            const starCount = 40;
            const screenWidth = window.innerWidth || document.documentElement.clientWidth;
            const screenHeight = window.innerHeight || document.documentElement.clientHeight;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                const x = Math.random() * screenWidth;
                const y = Math.random() * screenHeight;
                const size = Math.random() * 3 + 5;
                const delay = Math.random() * 3;
                
                star.style.left = `${x}px`;
                star.style.top = `${y}px`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.animationDelay = `${delay}s`;
                star.style.webkitAnimationDelay = `${delay}s`;
                
                stars.appendChild(star);
            }
        }

        // 显示密码输入框（确保音频加载完成后再显示）
        function showPasswordUI() {
            // 防止重复执行
            if (isPasswordUIShowed) return;
            isPasswordUIShowed = true;

            loadingIndicator.style.display = 'none';
            maskHint.style.display = 'block';
            passwordInput.style.display = 'block';
            // 强制触发焦点，兼容移动端
            setTimeout(() => {
                try {
                    passwordInput.focus();
                    // 兼容iOS微信键盘呼出
                    passwordInput.click();
                } catch (e) {
                    console.log('焦点设置失败:', e);
                }
            }, 300);
        }

        // 加载音频（确保加载完成后再显示密码界面，增加超时兜底）
        function loadAudioGracefully() {
            // 1. 先绑定事件再执行load，避免错过事件
            const handleAudioReady = () => {
                console.log('✅ 音频加载完成，显示密码界面');
                showPasswordUI();
            };

            const handleAudioError = (err) => {
                console.error('❌ 音频加载失败:', err);
                showPasswordUI();
            };

            // 绑定音频事件
            audio.addEventListener('canplaythrough', handleAudioReady, { once: true });
            audio.addEventListener('error', handleAudioError, { once: true });
            audio.addEventListener('abort', handleAudioError, { once: true }); // 处理音频加载被中止的情况

            // 2. 超时兜底：5秒后强制显示密码界面（防止音频加载卡死）
            const timeoutTimer = setTimeout(() => {
                console.log('⏰ 音频加载超时，强制显示密码界面');
                showPasswordUI();
                // 移除未触发的事件监听
                audio.removeEventListener('canplaythrough', handleAudioReady);
                audio.removeEventListener('error', handleAudioError);
                audio.removeEventListener('abort', handleAudioError);
            }, 5000);

            // 3. 执行音频加载
            try {
                audio.load();
            } catch (e) {
                console.error('❌ 音频load执行失败:', e);
                clearTimeout(timeoutTimer);
                showPasswordUI();
            }
        }

        // 解析transform的Y偏移值（核心工具函数）
        function getTransformY(element) {
            const transform = getComputedStyle(element).transform;
            if (transform === 'none' || !transform) return 0;
            // 解析matrix(1,0,0,1,tx,ty)中的ty值
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (!matrix) return 0;
            const values = matrix[1].split(',').map(parseFloat);
            return values[5] || 0; // ty是第6个值
        }

        // 停止诗句上滑动画（核心修复：将transform偏移转为scrollTop）
        function stopPoemAnimation() {
            if (!isAnimating) return;
            
            // 1. 取消动画帧请求，终止动画循环
            cancelAnimationFrame(animationFrameId);
            // 2. 标记动画已停止
            isAnimating = false;
            
            // 3. 核心：将transform的Y偏移转换为容器的scrollTop
            const currentTransformY = getTransformY(poemContent);
            const containerHeight = poemContainer.clientHeight;
            
            // 计算需要设置的scrollTop：transformY是向下偏移（正值），转为scrollTop（向上滚动）
            // 公式：scrollTop = (容器高度 + 100) - currentTransformY - 顶部边距（保证第一行滑回时有正常边距）
            const topMargin = parseFloat(getComputedStyle(poemContent).marginTop) || 0;
            let targetScrollTop = (containerHeight + 100) - currentTransformY - topMargin;
            // 边界处理：scrollTop不能为负
            targetScrollTop = Math.max(0, targetScrollTop);
            
            // 4. 重置transform为0（移除偏移，让滚动仅依赖scrollTop）
            poemContent.style.transform = 'translateY(0)';
            poemContent.style.webkitTransform = 'translateY(0)';
            
            // 5. 设置容器的scrollTop，让诗句停在视觉同一位置
            poemContainer.scrollTop = targetScrollTop;
            
            // 6. 移除所有触碰/滚动监听（避免重复触发）
            poemContainer.removeEventListener('touchstart', stopPoemAnimation);
            poemContainer.removeEventListener('scroll', stopPoemAnimation);
            poemContainer.removeEventListener('mousedown', stopPoemAnimation);
        }

        // 诗句滑动动画函数（独立封装，便于调用）
        function startPoemAnimation() {
            const poemLine = poemContent;
            const containerHeight = poemContainer.clientHeight;
            // 初始位置已通过CSS设置，这里直接启动动画
            const startTime = performance.now();
            const duration = 5000; // 5秒
            
            // 标记动画开始
            isAnimating = true;
            
            // 绑定触碰/滚动事件：用户操作时停止动画
            poemContainer.addEventListener('touchstart', stopPoemAnimation, { once: true, passive: true });
            poemContainer.addEventListener('scroll', stopPoemAnimation, { once: true, passive: true });
            poemContainer.addEventListener('mousedown', stopPoemAnimation, { once: true, passive: true });

            const animate = () => {
                // 如果动画已停止，直接退出
                if (!isAnimating) return;
                
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 计算新的y位置（从底部外到顶部）
                const newY = (containerHeight + 100) - (containerHeight + 100) * progress;
                poemLine.style.transform = `translateY(${newY}px)`;
                poemLine.style.webkitTransform = `translateY(${newY}px)`;
                
                // 如果动画未完成，继续下一帧
                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    // 动画正常结束：转换为scrollTop并重置transform
                    stopPoemAnimation();
                }
            };
            
            animationFrameId = requestAnimationFrame(animate);
        }

        // 密码验证 & 核心逻辑触发
        passwordInput.addEventListener('input', (e) => {
            const inputValue = e.target.value.trim();
            if (inputValue === correctPassword) {
                // 隐藏密码层（通过CSS transition实现平滑隐藏）
                passwordMask.style.opacity = 0;
                passwordMask.style.pointerEvents = 'none';
                setTimeout(() => passwordMask.style.display = 'none', 500);

                // 显示核心内容
                stars.style.display = 'block';
                poemContainer.classList.add('show');
                
                // 立即启动诗句滑动动画（去掉500ms延迟，避免先显示诗句）
                startPoemAnimation();
                
                // 播放音频
                audio.play().catch(err => {
                    console.log('音频自动播放失败，点击页面播放:', err);
                    document.body.addEventListener('click', () => audio.play(), { once: true });
                });
            }
        });

        // 旋转屏幕适配（仅保留字体缩放兜底）
        window.addEventListener('resize', () => {
            document.documentElement.style.fontSize = '16px !important';
            document.body.style.webkitTextSizeAdjust = 'none !important';
        });
    </script>
</body>
</html>
